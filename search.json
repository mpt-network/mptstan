[{"path":"https://mpt-network.github.io/mptstan/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"GNU General Public License","title":"GNU General Public License","text":"Version 2, June 1991Copyright © 1989, 1991 Free Software Foundation, Inc.,51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA Everyone permitted copy distribute verbatim copies license document, changing allowed.","code":""},{"path":"https://mpt-network.github.io/mptstan/LICENSE.html","id":"preamble","dir":"","previous_headings":"","what":"Preamble","title":"GNU General Public License","text":"licenses software designed take away freedom share change . contrast, GNU General Public License intended guarantee freedom share change free software–make sure software free users. General Public License applies Free Software Foundation’s software program whose authors commit using . (Free Software Foundation software covered GNU Lesser General Public License instead.) can apply programs, . speak free software, referring freedom, price. General Public Licenses designed make sure freedom distribute copies free software (charge service wish), receive source code can get want , can change software use pieces new free programs; know can things. protect rights, need make restrictions forbid anyone deny rights ask surrender rights. restrictions translate certain responsibilities distribute copies software, modify . example, distribute copies program, whether gratis fee, must give recipients rights . must make sure , , receive can get source code. must show terms know rights. protect rights two steps: (1) copyright software, (2) offer license gives legal permission copy, distribute /modify software. Also, author’s protection , want make certain everyone understands warranty free software. software modified someone else passed , want recipients know original, problems introduced others reflect original authors’ reputations. Finally, free program threatened constantly software patents. wish avoid danger redistributors free program individually obtain patent licenses, effect making program proprietary. prevent , made clear patent must licensed everyone’s free use licensed . precise terms conditions copying, distribution modification follow.","code":""},{"path":"https://mpt-network.github.io/mptstan/LICENSE.html","id":"terms-and-conditions-for-copying-distribution-and-modification","dir":"","previous_headings":"","what":"TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION","title":"GNU General Public License","text":"0. License applies program work contains notice placed copyright holder saying may distributed terms General Public License. “Program”, , refers program work, “work based Program” means either Program derivative work copyright law: say, work containing Program portion , either verbatim modifications /translated another language. (Hereinafter, translation included without limitation term “modification”.) licensee addressed “”. Activities copying, distribution modification covered License; outside scope. act running Program restricted, output Program covered contents constitute work based Program (independent made running Program). Whether true depends Program . 1. may copy distribute verbatim copies Program’s source code receive , medium, provided conspicuously appropriately publish copy appropriate copyright notice disclaimer warranty; keep intact notices refer License absence warranty; give recipients Program copy License along Program. may charge fee physical act transferring copy, may option offer warranty protection exchange fee. 2. may modify copy copies Program portion , thus forming work based Program, copy distribute modifications work terms Section 1 , provided also meet conditions: ) must cause modified files carry prominent notices stating changed files date change. b) must cause work distribute publish, whole part contains derived Program part thereof, licensed whole charge third parties terms License. c) modified program normally reads commands interactively run, must cause , started running interactive use ordinary way, print display announcement including appropriate copyright notice notice warranty (else, saying provide warranty) users may redistribute program conditions, telling user view copy License. (Exception: Program interactive normally print announcement, work based Program required print announcement.) requirements apply modified work whole. identifiable sections work derived Program, can reasonably considered independent separate works , License, terms, apply sections distribute separate works. distribute sections part whole work based Program, distribution whole must terms License, whose permissions licensees extend entire whole, thus every part regardless wrote . Thus, intent section claim rights contest rights work written entirely ; rather, intent exercise right control distribution derivative collective works based Program. addition, mere aggregation another work based Program Program (work based Program) volume storage distribution medium bring work scope License. 3. may copy distribute Program (work based , Section 2) object code executable form terms Sections 1 2 provided also one following: ) Accompany complete corresponding machine-readable source code, must distributed terms Sections 1 2 medium customarily used software interchange; , b) Accompany written offer, valid least three years, give third party, charge cost physically performing source distribution, complete machine-readable copy corresponding source code, distributed terms Sections 1 2 medium customarily used software interchange; , c) Accompany information received offer distribute corresponding source code. (alternative allowed noncommercial distribution received program object code executable form offer, accord Subsection b .) source code work means preferred form work making modifications . executable work, complete source code means source code modules contains, plus associated interface definition files, plus scripts used control compilation installation executable. However, special exception, source code distributed need include anything normally distributed (either source binary form) major components (compiler, kernel, ) operating system executable runs, unless component accompanies executable. distribution executable object code made offering access copy designated place, offering equivalent access copy source code place counts distribution source code, even though third parties compelled copy source along object code. 4. may copy, modify, sublicense, distribute Program except expressly provided License. attempt otherwise copy, modify, sublicense distribute Program void, automatically terminate rights License. However, parties received copies, rights, License licenses terminated long parties remain full compliance. 5. required accept License, since signed . However, nothing else grants permission modify distribute Program derivative works. actions prohibited law accept License. Therefore, modifying distributing Program (work based Program), indicate acceptance License , terms conditions copying, distributing modifying Program works based . 6. time redistribute Program (work based Program), recipient automatically receives license original licensor copy, distribute modify Program subject terms conditions. may impose restrictions recipients’ exercise rights granted herein. responsible enforcing compliance third parties License. 7. , consequence court judgment allegation patent infringement reason (limited patent issues), conditions imposed (whether court order, agreement otherwise) contradict conditions License, excuse conditions License. distribute satisfy simultaneously obligations License pertinent obligations, consequence may distribute Program . example, patent license permit royalty-free redistribution Program receive copies directly indirectly , way satisfy License refrain entirely distribution Program. portion section held invalid unenforceable particular circumstance, balance section intended apply section whole intended apply circumstances. purpose section induce infringe patents property right claims contest validity claims; section sole purpose protecting integrity free software distribution system, implemented public license practices. Many people made generous contributions wide range software distributed system reliance consistent application system; author/donor decide willing distribute software system licensee impose choice. section intended make thoroughly clear believed consequence rest License. 8. distribution /use Program restricted certain countries either patents copyrighted interfaces, original copyright holder places Program License may add explicit geographical distribution limitation excluding countries, distribution permitted among countries thus excluded. case, License incorporates limitation written body License. 9. Free Software Foundation may publish revised /new versions General Public License time time. new versions similar spirit present version, may differ detail address new problems concerns. version given distinguishing version number. Program specifies version number License applies “later version”, option following terms conditions either version later version published Free Software Foundation. Program specify version number License, may choose version ever published Free Software Foundation. 10. wish incorporate parts Program free programs whose distribution conditions different, write author ask permission. software copyrighted Free Software Foundation, write Free Software Foundation; sometimes make exceptions . decision guided two goals preserving free status derivatives free software promoting sharing reuse software generally.","code":""},{"path":"https://mpt-network.github.io/mptstan/LICENSE.html","id":"no-warranty","dir":"","previous_headings":"","what":"NO WARRANTY","title":"GNU General Public License","text":"11. PROGRAM LICENSED FREE CHARGE, WARRANTY PROGRAM, EXTENT PERMITTED APPLICABLE LAW. EXCEPT OTHERWISE STATED WRITING COPYRIGHT HOLDERS /PARTIES PROVIDE PROGRAM “” WITHOUT WARRANTY KIND, EITHER EXPRESSED IMPLIED, INCLUDING, LIMITED , IMPLIED WARRANTIES MERCHANTABILITY FITNESS PARTICULAR PURPOSE. ENTIRE RISK QUALITY PERFORMANCE PROGRAM . PROGRAM PROVE DEFECTIVE, ASSUME COST NECESSARY SERVICING, REPAIR CORRECTION. 12. EVENT UNLESS REQUIRED APPLICABLE LAW AGREED WRITING COPYRIGHT HOLDER, PARTY MAY MODIFY /REDISTRIBUTE PROGRAM PERMITTED , LIABLE DAMAGES, INCLUDING GENERAL, SPECIAL, INCIDENTAL CONSEQUENTIAL DAMAGES ARISING USE INABILITY USE PROGRAM (INCLUDING LIMITED LOSS DATA DATA RENDERED INACCURATE LOSSES SUSTAINED THIRD PARTIES FAILURE PROGRAM OPERATE PROGRAMS), EVEN HOLDER PARTY ADVISED POSSIBILITY DAMAGES. END TERMS CONDITIONS","code":""},{"path":"https://mpt-network.github.io/mptstan/LICENSE.html","id":"how-to-apply-these-terms-to-your-new-programs","dir":"","previous_headings":"","what":"How to Apply These Terms to Your New Programs","title":"GNU General Public License","text":"develop new program, want greatest possible use public, best way achieve make free software everyone can redistribute change terms. , attach following notices program. safest attach start source file effectively convey exclusion warranty; file least “copyright” line pointer full notice found. Also add information contact electronic paper mail. program interactive, make output short notice like starts interactive mode: hypothetical commands show w show c show appropriate parts General Public License. course, commands use may called something show w show c; even mouse-clicks menu items–whatever suits program. also get employer (work programmer) school, , sign “copyright disclaimer” program, necessary. sample; alter names: General Public License permit incorporating program proprietary programs. program subroutine library, may consider useful permit linking proprietary applications library. want , use GNU Lesser General Public License instead License.","code":"<one line to give the program's name and a brief idea of what it does.> Copyright (C) <year>  <name of author>  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA. Gnomovision version 69, Copyright (C) year name of author Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'. This is free software, and you are welcome to redistribute it under certain conditions; type `show c' for details. Yoyodyne, Inc., hereby disclaims all copyright interest in the program `Gnomovision' (which makes passes at compilers) written by James Hacker.  <signature of Ty Coon>, 1 April 1989 Ty Coon, President of Vice"},{"path":"https://mpt-network.github.io/mptstan/articles/Comprehensive-Fit-Example-with-Crossed-Random-Effects.html","id":"step-1-create-mpt-model-object","dir":"Articles","previous_headings":"","what":"Step 1: Create MPT Model Object","title":"Comprehensive Fit Example with Crossed-Random Effects","text":"first step using mptstan creation MPT model object using make_mpt() (creates object class mpt_model). make_mpt() can read MPT models commonly used EQN model format (e.g., used TreeBUGS) easy format introduced MPTinR. shown output, model parameter ends number, mptstan adds x parameter name (brms handle custom parameters ending number). model already parameter name (.e., original parameter name ending number plus x) might leave problems avoided.","code":"# For the easy EQN format, we just need the EQN file location: EQNFILE <- system.file(\"extdata\", \"u2htm.eqn\", package = \"mptstan\") u2htsm_model <- make_mpt(EQNFILE) ## make_mpt() auto-detects EQN files from name #> model type auto-detected as 'eqn' #> Warning: parameter names ending with a number amended with 'x' u2htsm_model #>  #> MPT model with 4 independent categories (from 2 trees) and 4 parameters: #>   Dn, Do, g1x, g2x #>  #> Tree 1: old #>   Categories: old, unsure, new  #>   Parameters: Do, g1x, g2x #> Tree 2: new #>   Categories: old, unsure, new  #>   Parameters: Dn, g1x, g2x  ## Alternatively, we can just enter the equations and use the easy format. u2htm <- \" # Old Items Do + (1 - Do) * (1 - g1) * g2 (1 - Do) * g1 (1 - Do) * (1 - g1) * (1 - g2)  # New Items (1 - Dn) * (1 - g1) * g2 (1 - Dn) * g1 Dn + (1 - Dn) * (1 - g1) * (1 - g2) \" # for the easy format, we need to specify tree names and category names u2htsm_model_2 <- make_mpt(text = u2htm,                             trees = c(\"old\", \"new\"),                            categories = rep(c(\"old\", \"unsure\", \"new\"), 2)) #> Warning: parameter names ending with a number amended with 'x' u2htsm_model_2 #>  #> MPT model with 4 independent categories (from 2 trees) and 4 parameters: #>   Dn, Do, g1x, g2x #>  #> Tree 1: old #>   Categories: old, unsure, new  #>   Parameters: Do, g1x, g2x #> Tree 2: new #>   Categories: old, unsure, new  #>   Parameters: Dn, g1x, g2x"},{"path":"https://mpt-network.github.io/mptstan/articles/Comprehensive-Fit-Example-with-Crossed-Random-Effects.html","id":"step-2-create-formula-optional","dir":"Articles","previous_headings":"","what":"Step 2: Create Formula (Optional)","title":"Comprehensive Fit Example with Crossed-Random Effects","text":"second optional step creating MPT formula object mpt_formula(). , show case formula applies MPT model parameters. case, specify single formula also need pass MPT model object (model argument). formula, left-hand-side specifies response variable (present case resp) right-hand side specifies fixed-effect regression coefficients random-effect (.e., multilevel) structure using brms-extended lme4 syntax. , one fixed-effect, race factor. Furthermore, -participant -item random-effect terms. -participant random-effect term estimate random intercepts random slopes race (race within-participants factor). -item random-effect term estimate random intercepts. random-effect terms add unique identifier regression structure random-effect term (.e., race 1) grouping factor (.e., id stim), p participants items. identifiers ensures random-effect correlations estimated across MPT model parameters. words, identifiers ensure random-effect term full correlation matrix across MPT model parameters estimated line Klauer’s (2010) latent trait approach. shown output, specify MPT model formula single formula, formula applies MPT model parameters. case, using mpt_formula() optional also specify formula first argument fitting function, mpt(). Creating formula object optional want specify individual potentially different formula MPT model parameter. case, left-hand-side formula needs specify MPT model parameter response variable needs specified via response argument. examples, see ?mpt_formula.","code":"u2htm_formula <- mpt_formula(resp ~ race + (race|p|id) + (1|i|stim),                               model = u2htsm_model) u2htm_formula #> MPT formulas for long / non-aggregated data (response: resp): #> Dn ~ race + (race | p | id) + (1 | i | stim) #> Do ~ race + (race | p | id) + (1 | i | stim) #> g1x ~ race + (race | p | id) + (1 | i | stim) #> g2x ~ race + (race | p | id) + (1 | i | stim)"},{"path":"https://mpt-network.github.io/mptstan/articles/Comprehensive-Fit-Example-with-Crossed-Random-Effects.html","id":"step-3-fit-model","dir":"Articles","previous_headings":"","what":"Step 3: Fit Model","title":"Comprehensive Fit Example with Crossed-Random Effects","text":"MPT model object model formula ready fit MPT model. , use function mpt() addition two aforementioned objects requires data well variable data distinguishing tree (data type) particular response belongs. present case type variable. (tree variable can omitted case model consists solely one tree.) addition required arguments (model object, formula, data, tree variable), can pass arguments brms::brm() onward rstan::stan(), ultimately performs MCMC sampling. , also pass init_r = 0.5 ensures random start values drawn uniform distribution ranging -0.5 0.5 (instead default -2 2). testing shown init_r = 0.5 MPT models random-effect terms much less likely fail initialisation. pass arguments chains, warmup, iter, thin control MCMC sampling. Note fitting model can take hour longer (depending computer).","code":"fit_skk <- mpt(u2htm_formula, data = skk13,                tree = \"type\",                init_r = 0.5 ) #> Warning: Bulk Effective Samples Size (ESS) is too low, indicating posterior means and medians may be unreliable. #> Running the chains for more iterations may help. See #> https://mc-stan.org/misc/warnings.html#bulk-ess #> Warning: Tail Effective Samples Size (ESS) is too low, indicating posterior variances and tail quantiles may be unreliable. #> Running the chains for more iterations may help. See #> https://mc-stan.org/misc/warnings.html#tail-ess"},{"path":"https://mpt-network.github.io/mptstan/articles/Comprehensive-Fit-Example-with-Crossed-Random-Effects.html","id":"step-4-post-processing","dir":"Articles","previous_headings":"","what":"Step 4: Post-Processing","title":"Comprehensive Fit Example with Crossed-Random Effects","text":"mptstan uses brms::brm() model estimation returns brmsfit object. consequence, full post-processing functionality brms associated packages available (e.g., emmeans, tidybayes). However, time mptstan contain many MPT-specific post-processing functionality exception mpt_emmeans introduced . Thus, brms post-processing functionality mostly available. Whereas functionality rather sophisticated flexible, always perfect MPT models many parameters. inspecting post-processing output brms, important thing understand brms label first parameter model (.e., shown model object). example, model parameter Intercept refers intercept first MPT model parameter (.e., Dn present case). parameters labelled corresponding MPT model parameter name, first MPT model parameter. default summary() method brms objects first lists estimates random-effects terms estimates fixed-effects regression coefficients. mentioned previous paragraphs, estimates label clarifying MPT model parameter refer exception estimates referring first MPT model parameter, Dn. Typically primary interest fixed-effect regression coefficients can found table labelled “Regression Coefficients”. estimates smaller zero larger one, possible MPT parameter estimates (probability scale). reason values estimates shown unconstrained linear – , probit – scale. Looking table regression coefficients see two different types estimates four MPT model parameters, four intercepts four slopes effect race (recall estimates without parameter label Dn parameter). inspecting four slopes detail can see one slopes, race1 coefficient Dn parameter, 95% CI include 0. indicates evidence Dn differs two different types face stimuli (.e., German versus Arabic faces). finding line results reported Singmann et al. (2013). Hence, even though table regression coefficients probit scale, can situations present one still derive meaningful conclusions . One way obtain estimates MPT parameter scale using package emmeans. mptstan comes convenience wrapper emmeans, called mpt_emmeans(), provides output MPT model parameter simultaneously otherwise works exactly like emmeans() function: can also use special syntax \"1\" get overall mean estimate parameter. Note , non-linear probit transformation, might different means marginal means. Another MPT model specific function ppp_test(), calculate posterior predictive pp-value test model’s fit. specifically, function currently implements T1-test statistic Klauer (2010). pp-value small, say smaller .05, indicates insufficient fit model misfit – words, significant divergence observed data data expected arise fitted model data generating model. present case pp-value clearly large (.e., near .5) indicating adequate model fit. Given unsure-extended 2-high threshold model saturated MPT model (number parameters equal number independent categories), good fit probably surprising. mentioned , mptstan also provides full integration brms post-processing. example, can obtain graphical posterior predictive checks using pp_check(). MPT models, type = \"bars_grouped\" provides helpful plot additional pass group = \"mpt_tree\" (creates one panel per tree). can also change x-axis labels match response categories. addition, can directly obtain information criteria loo get posterior mean/expectation predictions observation.","code":"summary(fit_skk) #>  Family: mpt  #>   Links: mu = probit; Do = probit; g1x = probit; g2x = probit  #> Formula: resp ~ race + (race | p | id) + (1 | i | stim)  #>          Do ~ race + (race | p | id) + (1 | i | stim) #>          g1x ~ race + (race | p | id) + (1 | i | stim) #>          g2x ~ race + (race | p | id) + (1 | i | stim) #>    Data: structure(list(id = structure(c(1L, 1L, 1L, 1L, 1L (Number of observations: 8400)  #>   Draws: 4 chains, each with iter = 2000; warmup = 1000; thin = 1; #>          total post-warmup draws = 4000 #>  #> Multilevel Hyperparameters: #> ~id (Number of levels: 42)  #>                                  Estimate Est.Error l-95% CI u-95% CI Rhat #> sd(Intercept)                        0.78      0.18     0.48     1.20 1.01 #> sd(race1)                            0.11      0.09     0.00     0.33 1.01 #> sd(Do_Intercept)                     0.56      0.09     0.41     0.75 1.00 #> sd(Do_race1)                         0.09      0.05     0.01     0.21 1.01 #> sd(g1x_Intercept)                    1.06      0.15     0.81     1.41 1.00 #> sd(g1x_race1)                        0.15      0.05     0.07     0.25 1.00 #> sd(g2x_Intercept)                    0.54      0.09     0.38     0.74 1.00 #> sd(g2x_race1)                        0.24      0.06     0.14     0.36 1.00 #> cor(Intercept,race1)                -0.04      0.33    -0.66     0.62 1.00 #> cor(Intercept,Do_Intercept)          0.44      0.17     0.07     0.73 1.00 #> cor(race1,Do_Intercept)             -0.07      0.32    -0.64     0.59 1.00 #> cor(Intercept,Do_race1)              0.05      0.29    -0.53     0.60 1.00 #> cor(race1,Do_race1)                 -0.06      0.33    -0.66     0.58 1.00 #> cor(Do_Intercept,Do_race1)           0.19      0.30    -0.44     0.71 1.00 #> cor(Intercept,g1x_Intercept)        -0.02      0.21    -0.41     0.41 1.01 #> cor(race1,g1x_Intercept)            -0.02      0.33    -0.65     0.62 1.02 #> cor(Do_Intercept,g1x_Intercept)      0.02      0.16    -0.30     0.35 1.01 #> cor(Do_race1,g1x_Intercept)         -0.21      0.28    -0.66     0.41 1.00 #> cor(Intercept,g1x_race1)            -0.17      0.24    -0.62     0.33 1.00 #> cor(race1,g1x_race1)                -0.06      0.32    -0.66     0.56 1.00 #> cor(Do_Intercept,g1x_race1)          0.26      0.21    -0.18     0.66 1.00 #> cor(Do_race1,g1x_race1)             -0.02      0.31    -0.61     0.58 1.00 #> cor(g1x_Intercept,g1x_race1)         0.28      0.25    -0.26     0.71 1.00 #> cor(Intercept,g2x_Intercept)        -0.43      0.19    -0.77    -0.02 1.01 #> cor(race1,g2x_Intercept)             0.04      0.32    -0.58     0.64 1.00 #> cor(Do_Intercept,g2x_Intercept)      0.02      0.18    -0.32     0.38 1.00 #> cor(Do_race1,g2x_Intercept)          0.03      0.29    -0.54     0.59 1.00 #> cor(g1x_Intercept,g2x_Intercept)     0.19      0.19    -0.20     0.52 1.01 #> cor(g1x_race1,g2x_Intercept)         0.25      0.24    -0.22     0.69 1.00 #> cor(Intercept,g2x_race1)             0.32      0.21    -0.14     0.69 1.00 #> cor(race1,g2x_race1)                 0.12      0.34    -0.55     0.71 1.01 #> cor(Do_Intercept,g2x_race1)          0.16      0.19    -0.23     0.52 1.00 #> cor(Do_race1,g2x_race1)              0.15      0.30    -0.47     0.69 1.01 #> cor(g1x_Intercept,g2x_race1)         0.13      0.21    -0.29     0.53 1.00 #> cor(g1x_race1,g2x_race1)            -0.16      0.27    -0.65     0.38 1.00 #> cor(g2x_Intercept,g2x_race1)        -0.12      0.22    -0.54     0.32 1.00 #>                                  Bulk_ESS Tail_ESS #> sd(Intercept)                        1114     1903 #> sd(race1)                             862     2017 #> sd(Do_Intercept)                     1601     2373 #> sd(Do_race1)                          608     1192 #> sd(g1x_Intercept)                    1769     2106 #> sd(g1x_race1)                        1927     1821 #> sd(g2x_Intercept)                     776     1791 #> sd(g2x_race1)                         808     1606 #> cor(Intercept,race1)                 3807     2430 #> cor(Intercept,Do_Intercept)          1042     1701 #> cor(race1,Do_Intercept)               423      898 #> cor(Intercept,Do_race1)              3241     2495 #> cor(race1,Do_race1)                  1350     2299 #> cor(Do_Intercept,Do_race1)           2825     2447 #> cor(Intercept,g1x_Intercept)          457     1061 #> cor(race1,g1x_Intercept)              192      301 #> cor(Do_Intercept,g1x_Intercept)       998     1948 #> cor(Do_race1,g1x_Intercept)           416      586 #> cor(Intercept,g1x_race1)             2180     2803 #> cor(race1,g1x_race1)                  686     1955 #> cor(Do_Intercept,g1x_race1)          3188     3305 #> cor(Do_race1,g1x_race1)              1255     2886 #> cor(g1x_Intercept,g1x_race1)         3506     3328 #> cor(Intercept,g2x_Intercept)          768     1832 #> cor(race1,g2x_Intercept)              595     1128 #> cor(Do_Intercept,g2x_Intercept)      1788     2546 #> cor(Do_race1,g2x_Intercept)           935     1664 #> cor(g1x_Intercept,g2x_Intercept)      810     2139 #> cor(g1x_race1,g2x_Intercept)         1410     2385 #> cor(Intercept,g2x_race1)             1072     1867 #> cor(race1,g2x_race1)                  418     1189 #> cor(Do_Intercept,g2x_race1)          2379     3131 #> cor(Do_race1,g2x_race1)               727     1226 #> cor(g1x_Intercept,g2x_race1)         1181     2442 #> cor(g1x_race1,g2x_race1)             1710     2484 #> cor(g2x_Intercept,g2x_race1)         1510     2899 #>  #> ~stim (Number of levels: 200)  #>                                  Estimate Est.Error l-95% CI u-95% CI Rhat #> sd(Intercept)                        0.88      0.14     0.63     1.20 1.00 #> sd(Do_Intercept)                     0.43      0.06     0.33     0.55 1.01 #> sd(g1x_Intercept)                    0.06      0.04     0.00     0.15 1.00 #> sd(g2x_Intercept)                    0.42      0.06     0.30     0.55 1.01 #> cor(Intercept,Do_Intercept)          0.31      0.17    -0.01     0.63 1.01 #> cor(Intercept,g1x_Intercept)        -0.15      0.39    -0.82     0.65 1.00 #> cor(Do_Intercept,g1x_Intercept)     -0.25      0.40    -0.88     0.62 1.00 #> cor(Intercept,g2x_Intercept)        -0.43      0.22    -0.81    -0.01 1.01 #> cor(Do_Intercept,g2x_Intercept)     -0.05      0.19    -0.39     0.32 1.02 #> cor(g1x_Intercept,g2x_Intercept)    -0.07      0.41    -0.79     0.75 1.02 #>                                  Bulk_ESS Tail_ESS #> sd(Intercept)                        1215     1861 #> sd(Do_Intercept)                      819     1611 #> sd(g1x_Intercept)                     971     1892 #> sd(g2x_Intercept)                     436     1067 #> cor(Intercept,Do_Intercept)           423      913 #> cor(Intercept,g1x_Intercept)         2908     2313 #> cor(Do_Intercept,g1x_Intercept)      2597     2648 #> cor(Intercept,g2x_Intercept)          296      773 #> cor(Do_Intercept,g2x_Intercept)       507     1200 #> cor(g1x_Intercept,g2x_Intercept)      119      279 #>  #> Regression Coefficients: #>               Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS #> Intercept        -0.55      0.22    -1.00    -0.17 1.01      746     1605 #> Do_Intercept      0.14      0.11    -0.08     0.35 1.01      839     1780 #> g1x_Intercept    -1.35      0.17    -1.71    -1.01 1.00     1420     2100 #> g2x_Intercept    -0.38      0.12    -0.62    -0.15 1.00      852     2367 #> race1             0.37      0.12     0.15     0.60 1.00     1312     2034 #> Do_race1          0.01      0.05    -0.09     0.11 1.00     1775     2505 #> g1x_race1        -0.06      0.04    -0.15     0.03 1.00     2877     3014 #> g2x_race1        -0.13      0.07    -0.27     0.01 1.00     1264     2532 #>  #> Draws were sampled using sampling(NUTS). For each parameter, Bulk_ESS #> and Tail_ESS are effective sample size measures, and Rhat is the potential #> scale reduction factor on split chains (at convergence, Rhat = 1). mpt_emmeans(fit_skk, \"race\") #>   parameter   race   response  lower.HPD upper.HPD #> 1        Dn german 0.43305661 0.24889660 0.5938111 #> 2        Dn arabic 0.18455338 0.06265918 0.3093766 #> 3        Do german 0.56213484 0.46394103 0.6510327 #> 4        Do arabic 0.55176900 0.46281825 0.6424701 #> 5       g1x german 0.08032168 0.03225784 0.1407091 #> 6       g1x arabic 0.09857215 0.04504090 0.1602572 #> 7       g2x german 0.30406461 0.20843582 0.4077200 #> 8       g2x arabic 0.39994499 0.30632449 0.5048775 mpt_emmeans(fit_skk, \"1\") #>   parameter      X1   response  lower.HPD upper.HPD #> 1        Dn overall 0.29757056 0.15962015 0.4325167 #> 2        Do overall 0.55653868 0.47342278 0.6399529 #> 3       g1x overall 0.08928845 0.04009512 0.1488125 #> 4       g2x overall 0.35150225 0.26724324 0.4370866 ppp_test(fit_skk) #>  ## Mean structure (T1): #>  Observed =  3.293324 ; Predicted =  3.210767 ; p-value =  0.491 pp_check(fit_skk, type = \"bars_grouped\", group = \"mpt_tree\", ndraws = 100) +   ggplot2::scale_x_continuous(breaks = 1:3, labels = c(\"old\", \"unsure\", \"new\")) #> Scale for x is already present. #> Adding another scale for x, which will replace the existing scale. (loo_model <- loo(fit_skk)) #>  #> Computed from 4000 by 8400 log-likelihood matrix. #>  #>          Estimate    SE #> elpd_loo  -5678.4  63.0 #> p_loo       459.7   7.7 #> looic     11356.8 126.0 #> ------ #> MCSE of elpd_loo is 0.4. #> MCSE and ESS estimates assume MCMC draws (r_eff in [0.4, 1.8]). #>  #> All Pareto k estimates are good (k < 0.7). #> See help('pareto-k-diagnostic') for details. pepred <- posterior_epred(fit_skk) str(pepred) ## [sample, observation, response category] #>  num [1:4000, 1:8400, 1:3] 0.367 0.413 0.381 0.364 0.496 ..."},{"path":"https://mpt-network.github.io/mptstan/articles/Comprehensive-Fit-Example-with-Crossed-Random-Effects.html","id":"priors","dir":"Articles","previous_headings":"","what":"Priors","title":"Comprehensive Fit Example with Crossed-Random Effects","text":"mptstan comes default priors fixed-effect regression coefficients. intercepts, uses Normal(0, 1) prior non-intercept coefficients (.e., slopes) Normal(0, 0.5) prior. priors can changed default_prior_intercept default_prior_coef arguments (see ?mpt). hierarchical structure, mptstan uses brms default priors.","code":""},{"path":"https://mpt-network.github.io/mptstan/articles/Comprehensive-Fit-Example-with-Crossed-Random-Effects.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"Comprehensive Fit Example with Crossed-Random Effects","text":"Klauer, K. C. (2010). Hierarchical Multinomial Processing Tree Models: Latent-Trait Approach. Psychometrika, 75(1), 70-98. https://doi.org/10.1007/s11336-009-9141-0 Rouder, J. N., Morey, R. D., Speckman, P. L., & Province, J. M. (2012). Default Bayes factors ANOVA designs. Journal Mathematical Psychology, 56(5), 356–374. https://doi.org/10.1016/j.jmp.2012.08.001 Singmann, H., Kellen, D., & Klauer, K. C. (2013). Investigating -Race Effect Germans towards Turks Arabs using Multinomial Processing Tree Models. M. Knauff, M. Pauen, N. Sebanz, & . Wachsmuth (Eds.), Proceedings 35th Annual Conference Cognitive Science Society (pp. 1330–1335). Austin, TX: Cognitive Science Society. http://singmann.org/download/publications/SKK-CogSci2013.pdf","code":""},{"path":"https://mpt-network.github.io/mptstan/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Henrik Singmann. Author, maintainer. Marie Jakob. Author. Daniel W. Heck. Contributor.","code":""},{"path":"https://mpt-network.github.io/mptstan/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Singmann H, Jakob M (2025). mptstan: MPT Models Using brms/Stan. R package version 0.0.0.9000, https://mpt-network.github.io/mptstan/.","code":"@Manual{,   title = {mptstan: MPT Models Using brms/Stan},   author = {Henrik Singmann and Marie Jakob},   year = {2025},   note = {R package version 0.0.0.9000},   url = {https://mpt-network.github.io/mptstan/}, }"},{"path":"https://mpt-network.github.io/mptstan/index.html","id":"mptstan","dir":"","previous_headings":"","what":"MPT Models Using brms/Stan","title":"MPT Models Using brms/Stan","text":"Estimate multinomial processing tree (MPT) models, model class popular cognitive psychology, Bayesian framework using package brms (.e., ultimately Stan). allows specifying models type multivariate normal hierarchical multilevel structure, including models single multiple random effects (.e., crossed random effects). Model specification can tailored model parameter.","code":""},{"path":"https://mpt-network.github.io/mptstan/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"MPT Models Using brms/Stan","text":"can install development version mptstan GitHub : mptstan based brms therefore Stan, need C++ compiler use package. Installation instructions C++ compiler operating system can found : https://github.com/stan-dev/rstan/wiki/RStan-Getting-Started","code":"# install.packages(\"devtools\") devtools::install_github(\"mpt-network/mptstan\")"},{"path":[]},{"path":"https://mpt-network.github.io/mptstan/reference/make_mpt.html","id":null,"dir":"Reference","previous_headings":"","what":"Create MPT model object — make_mpt","title":"Create MPT model object — make_mpt","text":"Create MPT model object either model file model string. model can popular eqn format commonly used MPT software easy format introduced MPTinR.","code":""},{"path":"https://mpt-network.github.io/mptstan/reference/make_mpt.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create MPT model object — make_mpt","text":"","code":"make_mpt(   file,   type = c(\"easy\", \"eqn\", \"eqn2\"),   restrictions,   trees,   categories,   text )"},{"path":"https://mpt-network.github.io/mptstan/reference/make_mpt.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create MPT model object — make_mpt","text":"file file name model file. type model type. \"easy\" format, line assumed correspond full equation one response category. \".eqn\" \"eqn2\" format, branch path tree given one line (eqn default format many MPT tools). default behaviour assume model \"easy\" format unless file ends .eqn. restrictions list parameter restrictions. trees \"easy\" format, optional vector tree names. Ignored otherwise. categories \"easy\" format, optional vector categories. Ignored otherwise. text alternative specification model via text instead file. Ignored file missing","code":""},{"path":"https://mpt-network.github.io/mptstan/reference/make_mpt.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create MPT model object — make_mpt","text":"object class mpt_model list following elements: model_df: data.frame representation model (basically .eqn format representation). list: model expression format, tree one list. check: Vector summed probabilities tree (1 well constructed model). ns: Overview model numerical form. parameters: Vector names model parameters. pred: function generates predicted probabilities model.","code":""},{"path":"https://mpt-network.github.io/mptstan/reference/make_mpt.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create MPT model object — make_mpt","text":"","code":"## read-in model in easy format (with model specified as text) u2htm <- \" # Old Items Do + (1 - Do) * (1 - g1) * g2 (1 - Do) * g1 (1 - Do) * (1 - g1) * (1 - g2)  # New Items (1 - Dn) * (1 - g1) * g2 (1 - Dn) * g1 Dn + (1 - Dn) * (1 - g1) * (1 - g2) \"  # need to specify tree names and category names u2htsm_model <- make_mpt(text = u2htm,                          trees = c(\"old\", \"new\"),                          categories = rep(c(\"old\", \"unsure\", \"new\"), 2)) #> Warning: parameter names ending with a number amended with 'x' u2htsm_model #>  #> MPT model with 4 independent categories (from 2 trees) and 4 parameters: #>   Dn, Do, g1x, g2x #>  #> Tree 1: old #>   Categories: old, unsure, new  #>   Parameters: Do, g1x, g2x #> Tree 2: new #>   Categories: old, unsure, new  #>   Parameters: Dn, g1x, g2x #>   # print model with eqn style print(u2htsm_model, eqn = TRUE) #>  #> MPT model with 4 independent categories (from 2 trees) and 4 parameters: #>   Dn, Do, g1x, g2x #>  #> Tree 1: old #>   Categories: old, unsure, new  #>   Parameters: Do, g1x, g2x #> Tree 2: new #>   Categories: old, unsure, new  #>   Parameters: Dn, g1x, g2x #>  #> Model EQN: #>   Tree Category               Equation #> 1  old      old                     Do #> 2  old      old     (1-Do)*(1-g1x)*g2x #> 3  old   unsure             (1-Do)*g1x #> 4  old      new (1-Do)*(1-g1x)*(1-g2x) #> 5  new      old     (1-Dn)*(1-g1x)*g2x #> 6  new   unsure             (1-Dn)*g1x #> 7  new      new                     Dn #> 8  new      new (1-Dn)*(1-g1x)*(1-g2x) #>   # brms family object u2htsm_model$family #> NULL  ## write model as eqn file (add empty line on top): if (FALSE) { # \\dontrun{ write.table(u2htsm_model$df, file = \"u2htm.eqn\",            quote = FALSE, row.names = FALSE, col.names = FALSE) } # }  ## create same model, but from EQN file EQNFILE <- system.file(\"extdata\", \"u2htm.eqn\", package = \"mptstan\")  u2htsm_model_b <- make_mpt(EQNFILE) #> model type auto-detected as 'eqn' #> Warning: parameter names ending with a number amended with 'x' u2htsm_model_b #>  #> MPT model with 4 independent categories (from 2 trees) and 4 parameters: #>   Dn, Do, g1x, g2x #>  #> Tree 1: old #>   Categories: old, unsure, new  #>   Parameters: Do, g1x, g2x #> Tree 2: new #>   Categories: old, unsure, new  #>   Parameters: Dn, g1x, g2x #>"},{"path":"https://mpt-network.github.io/mptstan/reference/mpt.html","id":null,"dir":"Reference","previous_headings":"","what":"Fit Bayesian MPT Models with brms & Stan — mpt","title":"Fit Bayesian MPT Models with brms & Stan — mpt","text":"Fit Bayesian multinomial processing tree (MPT) model using brms::brm() (ultimately Stan) trial-level data, potentially including multilevel/hierarchical model structure. fit MPT, first create model object using make_mpt() pass model object, data, well formula providing symbolic description regression (.e., fixed-effect) hierarchical (.e., random-effect) structure. returned object can used model post-processing.","code":""},{"path":"https://mpt-network.github.io/mptstan/reference/mpt.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fit Bayesian MPT Models with brms & Stan — mpt","text":"","code":"mpt(   formula,   data,   tree,   model,   default_prior_intercept = \"normal(0, 1)\",   default_prior_coef = \"normal(0, 0.5)\",   default_priors = TRUE,   data_format = \"long\",   log_p = FALSE,   link = \"probit\",   ... )"},{"path":"https://mpt-network.github.io/mptstan/reference/mpt.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fit Bayesian MPT Models with brms & Stan — mpt","text":"formula Either formula applied MPT model parameter mpt_formula object (created mpt_formula()) specifying separate formulas parameter. formula, LHS needs specify response variable. data data.frame containing variables formula. Data needs observation-level (.e., row one response/observation) aggregated way. TODO: change tree one-sided formula character specifying variable data indicating tree (item type) given observation. values tree variable need match names trees model. Can omitted models one tree. model mpt_model object created make_mpt(), ignored formula object mpt_formula. default_prior_intercept character string describing prior applied fixed-effect intercepts MPT model parameter unconstrained scale (default_priors = TRUE). default, \"normal(0, 1)\" implies flat prior MPT parameter scale. default_prior_coef character string describing prior applied non-intercept fixed-effect parameters MPT model parameter unconstrained scale (default_priors = TRUE). default_priors logical value indicating whether (default, TRUE) (FALSE) priors specified via default_prior_intercept default_prior_coef argument applied. data_format character string indicating whether formula generated fitting data long format / non-aggregated data (long, default), single variable contains trial-level responses, data wide format / aggregated data (wide / aggregated), separate column response category contains respective .  frequency. used formula object (mpt_formula) given input ignored otherwise. log_p logical value indicating whether likelihood evaluated probabilities (default, FALSE) log probabilities (TRUE). Setting log_p TRUE can help case convergence issues might slower. link character specifying link function transforming unconstrained space MPT model parameter (.e., 0 1) space. Default \"probit\". ... arguments passed brms::brm() prior, chains, iter, warmup, cores.","code":""},{"path":"https://mpt-network.github.io/mptstan/reference/mpt.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fit Bayesian MPT Models with brms & Stan — mpt","text":"fitted model object returned brms::brm() class brmsfit additional class mpt_fit extra slots (.e., call, mpt_formula, orig_data). object seemlessly interact brms ecosystem (e.g., can used obtaining posterior predictive values information criteria, see Examples).","code":""},{"path":"https://mpt-network.github.io/mptstan/reference/mpt.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fit Bayesian MPT Models with brms & Stan — mpt","text":"","code":"if (FALSE) { # \\dontrun{ ### Step 1: Specify model using make_mpt() ## model in easy format (with model specified as text) ## unsure-extended 2-high threshold model for recognition memory u2htm <- \" # Old Items Do + (1 - Do) * (1 - g1) * g2 (1 - Do) * g1 (1 - Do) * (1 - g1) * (1 - g2)  # New Items (1 - Dn) * (1 - g1) * g2 (1 - Dn) * g1 Dn + (1 - Dn) * (1 - g1) * (1 - g2) \"  # need to specify tree names and category names for easy format u2htsm_model <- make_mpt(text = u2htm, trees = c(\"old\", \"new\"),                          categories = rep(c(\"old\", \"unsure\", \"new\"), 2)) u2htsm_model   ### Step 2: Fit model with same formula for all model parameters  ## we fit to data from Singmann, Kellen, & Klauer (2013, CogSci-Proc): # Investigating the Other-Race Effect of Germans towards Turks and Arabs using # Multinomial Processing Tree Models # http://singmann.org/download/publications/SKK-CogSci2013.pdf str(skk13)  ## here we use simplified syntax without any random effects for fitting speed. fit_fast <- mpt(resp ~ race, data = skk13, model = u2htsm_model,                 tree = \"type\",                 cores = min(c(4, parallel::detectCores()))) ## uses multicore ## a more appropriate formula would be: resp ~ race + (race|s|id) + (1|p|stim) ## (i.e., crossed-random effects and full correlations among random terms)  ### Step 3: Inspect results fit_fast # in output, no parameter name refers to first MPT parameter (here: Dn)  ## Check model fit ppp_test(fit_fast)  ## we can use mpt_emmeans() for marginal effects of all MPT model parameters # requires package emmeans to be installed mpt_emmeans(fit_fast, \"race\")  ## Alternatively, we can invoke emmeans() individually for each MPT model parameter # Default is first MPT model parameter (here: Dn) emmeans::emmeans(fit_fast, \"race\", type = \"response\") # using the dpar argument, we can get output for any other model parameter emmeans::emmeans(fit_fast, \"race\", type = \"response\", dpar = \"Do\") emmeans::emmeans(fit_fast, \"race\", type = \"response\", dpar = \"g1x\") emmeans::emmeans(fit_fast, \"race\", type = \"response\", dpar = \"g2x\")  ## We can also use all brms post-processing # information criteria (e.g., loo) (loo_model <- loo(fit_fast)) # posterior predictive checks pp_check(fit_fast, type = \"bars_grouped\", group = \"mpt_tree\", ndraws = 100) # get posterior mean predictions pepred <- posterior_epred(fit_fast) str(pepred)  ## dimensions are: samples, observations, probability (in tree)  ### Alternative Step 2: First specify formula, then fit model ## Step 2a: Specify formula for each parameter separately using mpt_formula() ## (formula could be different for each model parameter) u2htm_formula <- mpt_formula(   Do ~ race + (race|s|id) + (1|p|stim),   Dn ~ race + (race|s|id) + (1|p|stim),   g1x ~ race + (race|s|id) + (1|p|stim),   g2x ~ race + (race|s|id) + (1|p|stim),   response = ~ resp,   model = u2htsm_model ) u2htm_formula  ## Step 2b: Fit model using formula (takes rather long) fit_slow <- mpt(u2htm_formula, data = skk13,                 tree = \"type\",                 cores = min(c(4, parallel::detectCores()))) ## uses multicore fit_slow } # }"},{"path":"https://mpt-network.github.io/mptstan/reference/mpt_emmeans.html","id":null,"dir":"Reference","previous_headings":"","what":"emmeans()-wrapper for MPT models — mpt_emmeans","title":"emmeans()-wrapper for MPT models — mpt_emmeans","text":"convenient interface emmeans::emmeans() MPT model parameters. Per default, results MPT model parameters combined one data.frame, can disabled using simplify argument.","code":""},{"path":"https://mpt-network.github.io/mptstan/reference/mpt_emmeans.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"emmeans()-wrapper for MPT models — mpt_emmeans","text":"","code":"mpt_emmeans(object, specs, by = NULL, type = \"response\", ..., simplify = TRUE)"},{"path":"https://mpt-network.github.io/mptstan/reference/mpt_emmeans.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"emmeans()-wrapper for MPT models — mpt_emmeans","text":"object fitted MPT model object returned mpt() specs emmeans::emmeans() emmeans::emmeans() type emmeans::summary.emmGrid(). Default MPT models \"response\" ... arguments passed emmeans::emmeans() corresponding methods simplify logical value indicating whether different results compiled one data.frame (TRUE, default) returned list","code":""},{"path":"https://mpt-network.github.io/mptstan/reference/mpt_formula.html","id":null,"dir":"Reference","previous_headings":"","what":"Set up MPT model formula — mpt_formula","title":"Set up MPT model formula — mpt_formula","text":"mpt_formula() sets model formula(s) specify regression structure hierarchical structure MPT model formulas. regression structure allows vary parameters across -participants within-participants conditions. using lme4/brms style syntax (e.g. (1|id)) random-effects (.e., hierarchical structure) can defined. mpt_formula objects, brms::stancode brms::standata methods provided.","code":""},{"path":"https://mpt-network.github.io/mptstan/reference/mpt_formula.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Set up MPT model formula — mpt_formula","text":"","code":"mpt_formula(   formula,   ...,   response,   model,   data_format = \"long\",   brms_args = list() )  # S3 method for class 'mpt_formula' stancode(   object,   data,   default_prior_intercept = \"normal(0, 1)\",   default_prior_coef = \"normal(0, 0.5)\",   default_priors = TRUE,   tree,   log_p = FALSE,   link = \"probit\",   ... )  # S3 method for class 'mpt_formula' standata(object, data, tree, ...)"},{"path":"https://mpt-network.github.io/mptstan/reference/mpt_formula.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Set up MPT model formula — mpt_formula","text":"formula object class formula providing symbolic description regression model hierarchical structure applied MPT model parameters. one formula given, left-hand-side (LHS) needs give response variable right-hand-side (RHS) gives model structure parameters. ... mpt_formula(), optional additional formula objects providing symbolic description regression model hierarchical structure applied remaining MPT model parameters. mpt_formula methods, additional arguments passed corresponding default methods. response one sided formula character vector giving name response variable. missing formula specified parameter data given long format (see data_format arg) model mpt_model object created make_mpt(). data_format character string indicating whether formula generated fitting data long format / non-aggregated data (long, default), single variable contains trial-level responses, data wide format / aggregated data (wide), separate column response category contains respective frequency. brms_args list additional arguments passed brms::brmsformula(), center, function ultimately creating formula fitting model. object object class mpt_formula data data.frame containing variables formula. Data needs observation-level (.e., row one response/observation) aggregated way. TODO: change default_prior_intercept character string describing prior applied fixed-effect intercepts MPT model parameter unconstrained scale (default_priors = TRUE). default, \"normal(0, 1)\" implies flat prior MPT parameter scale. default_prior_coef character string describing prior applied non-intercept fixed-effect parameters MPT model parameter unconstrained scale (default_priors = TRUE). default_priors logical value indicating whether (default, TRUE) (FALSE) priors specified via default_prior_intercept default_prior_coef argument applied. tree one-sided formula character specifying variable data indicating tree (item type) given observation. values tree variable need match names trees model. Can omitted models one tree. log_p logical value indicating whether likelihood evaluated probabilities (default, FALSE) log probabilities (TRUE). Setting log_p TRUE can help case convergence issues might slower. link character specifying link function transforming unconstrained space MPT model parameter (.e., 0 1) space. Default \"probit\".","code":""},{"path":"https://mpt-network.github.io/mptstan/reference/mpt_formula.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Set up MPT model formula — mpt_formula","text":"object class mpt_formula list containing following slots: formulas: list formulas MPT model parameter. response: one-sided formula given response variable RHS. brms_formula: brmsformula object created brms::brmsformula(). model: mpt_model object passed model argument. data_format: see corresponding argument brms::stancode brms::standata methods mpt_formula objects return objects corresponding default brms methods (internally called).","code":""},{"path":"https://mpt-network.github.io/mptstan/reference/mpt_formula.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Set up MPT model formula — mpt_formula","text":"two ways using mpt_formula() function: Specify single formula applies MPT model parameters (passed via model). case, LHS formula needs give response variable data long format (LHS ignored LHS given formula data wide format / aggregated data). Specify formula MPT model parameter model. case, LHS formula needs give parameters name. Furthermore, name response variable needs passed via response argument data long format.","code":""},{"path":"https://mpt-network.github.io/mptstan/reference/mpt_formula.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Set up MPT model formula — mpt_formula","text":"","code":"## Model with 4 parameters: Dn, Do, g1x, g2x EQNFILE <- system.file(\"extdata\", \"u2htm.eqn\", package = \"mptstan\") u2htsm_model <- make_mpt(EQNFILE) #> model type auto-detected as 'eqn' #> Warning: parameter names ending with a number amended with 'x' u2htsm_model #>  #> MPT model with 4 independent categories (from 2 trees) and 4 parameters: #>   Dn, Do, g1x, g2x #>  #> Tree 1: old #>   Categories: old, unsure, new  #>   Parameters: Do, g1x, g2x #> Tree 2: new #>   Categories: old, unsure, new  #>   Parameters: Dn, g1x, g2x #>   ## formulas are given for following data str(skk13) #> 'data.frame':\t8400 obs. of  7 variables: #>  $ id   : Factor w/ 42 levels \"1\",\"3\",\"5\",\"6\",..: 1 1 1 1 1 1 1 1 1 1 ... #>  $ trial: Factor w/ 200 levels \"1\",\"2\",\"3\",\"4\",..: 1 2 3 4 5 6 7 8 9 10 ... #>  $ race : Factor w/ 2 levels \"german\",\"arabic\": 2 1 1 1 1 1 1 2 1 1 ... #>  $ type : Factor w/ 2 levels \"old\",\"new\": 1 1 2 2 1 1 1 1 2 2 ... #>  $ resp : Factor w/ 3 levels \"old\",\"unsure\",..: 3 1 3 1 1 1 3 1 3 3 ... #>  $ rt   : num  4.68 2.75 4.25 1.6 0.95 ... #>  $ stim : Factor w/ 200 levels \"A001\",\"A002\",..: 40 132 117 143 140 162 193 19 120 170 ...  #### simplest possible formula: ~ 1 ## no random-effects and there is only one set of parameters (i.e., no ## differences across conditions). ## Same model holds for all MPT model parameters (f1 <- mpt_formula(resp ~ 1, model = u2htsm_model)) #> MPT formulas for long / non-aggregated data (response: resp): #> Dn ~ 1 #> <environment: 0x55eb8d1ba928> #> Do ~ 1 #> <environment: 0x55eb8d1ba928> #> g1x ~ 1 #> <environment: 0x55eb8d1ba928> #> g2x ~ 1 #> <environment: 0x55eb8d1ba928>  #### model with condition effects: ~ race ## Each parameter differs across the race variable (f2 <- mpt_formula(resp ~ race, model = u2htsm_model)) #> MPT formulas for long / non-aggregated data (response: resp): #> Dn ~ race #> <environment: 0x55eb8d1ba928> #> Do ~ race #> <environment: 0x55eb8d1ba928> #> g1x ~ race #> <environment: 0x55eb8d1ba928> #> g2x ~ race #> <environment: 0x55eb8d1ba928>  ### model with simple by-participant random effects ## because race is within-subject factor, we need random slopes for race ## this model only has correlations within one MPT model parameter (f3 <- mpt_formula(resp ~ race + (race|id), model = u2htsm_model)) #> MPT formulas for long / non-aggregated data (response: resp): #> Dn ~ race + (race | id) #> <environment: 0x55eb8d1ba928> #> Do ~ race + (race | id) #> <environment: 0x55eb8d1ba928> #> g1x ~ race + (race | id) #> <environment: 0x55eb8d1ba928> #> g2x ~ race + (race | id) #> <environment: 0x55eb8d1ba928>  ### model with correlated by-participant random effects ## to employ full latent-trait structure (Klauer, 2010), we need to have ## correlations across MPT model parameters (f4 <- mpt_formula(resp ~ race + (race|p|id), model = u2htsm_model)) #> MPT formulas for long / non-aggregated data (response: resp): #> Dn ~ race + (race | p | id) #> <environment: 0x55eb8d1ba928> #> Do ~ race + (race | p | id) #> <environment: 0x55eb8d1ba928> #> g1x ~ race + (race | p | id) #> <environment: 0x55eb8d1ba928> #> g2x ~ race + (race | p | id) #> <environment: 0x55eb8d1ba928>  ### model with crossed random-effects for participants and items: ## because race is a between-item factor (i.e., race is nested within) the item ## factor, we only have random intercepts for item, but they are correlated as ## well. (f5 <- mpt_formula(resp ~ race + (race|p|id) + (1|i|item), model = u2htsm_model)) #> MPT formulas for long / non-aggregated data (response: resp): #> Dn ~ race + (race | p | id) + (1 | i | item) #> <environment: 0x55eb8d1ba928> #> Do ~ race + (race | p | id) + (1 | i | item) #> <environment: 0x55eb8d1ba928> #> g1x ~ race + (race | p | id) + (1 | i | item) #> <environment: 0x55eb8d1ba928> #> g2x ~ race + (race | p | id) + (1 | i | item) #> <environment: 0x55eb8d1ba928>  ### we can also specify an individual structure for each parameters. ## In this case, we need to specify the response variable separately. (f6 <- mpt_formula(   Do ~ race + (race|p|id) + (1|i|item),   Dn ~ race + (race|p|id) + (1|i|item),   g1x ~ race + (race|p|id) + (1|i|item),   g2x ~ race + (race|p|id) + (1|i|item),   response = ~ resp,   model = u2htsm_model)) #> MPT formulas for long / non-aggregated data (response: resp): #> Dn ~ race + (race | p | id) + (1 | i | item) #> <environment: 0x55eb8d1ba928> #> Do ~ race + (race | p | id) + (1 | i | item) #> <environment: 0x55eb8d1ba928> #> g1x ~ race + (race | p | id) + (1 | i | item) #> <environment: 0x55eb8d1ba928> #> g2x ~ race + (race | p | id) + (1 | i | item) #> <environment: 0x55eb8d1ba928>  all.equal(f5, f6) ## TRUE #> [1] TRUE  ### can be more interesting, if we want different structures for each parameter (f7 <- mpt_formula(   Do ~ 1 + (1|p|id) + (1|i|item),   Dn ~ race + (race|p|id) + (1|i|item),   g1x ~ 1 + (1|p|id) + (1|i|item),   g2x ~ race + (race|p|id) + (1|i|item),   response = ~ resp,   model = u2htsm_model)) #> MPT formulas for long / non-aggregated data (response: resp): #> Dn ~ race + (race | p | id) + (1 | i | item) #> <environment: 0x55eb8d1ba928> #> Do ~ 1 + (1 | p | id) + (1 | i | item) #> <environment: 0x55eb8d1ba928> #> g1x ~ 1 + (1 | p | id) + (1 | i | item) #> <environment: 0x55eb8d1ba928> #> g2x ~ race + (race | p | id) + (1 | i | item) #> <environment: 0x55eb8d1ba928>"},{"path":"https://mpt-network.github.io/mptstan/reference/ppp_test.html","id":null,"dir":"Reference","previous_headings":"","what":"Posterior Predictive P-values for MPTs — ppp_test","title":"Posterior Predictive P-values for MPTs — ppp_test","text":"Calculates posterior predictive p-values MPT values. Currently T1 statistic Klauer (2010) implemented.","code":""},{"path":"https://mpt-network.github.io/mptstan/reference/ppp_test.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Posterior Predictive P-values for MPTs — ppp_test","text":"","code":"ppp_test(object, ndraws, type = \"X2\")"},{"path":"https://mpt-network.github.io/mptstan/reference/ppp_test.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Posterior Predictive P-values for MPTs — ppp_test","text":"object fitted MPT model object returned mpt(). ndraws number posterior draws used calculating posterior predictive p-values. type whether T1 statistic expected frequencies computed using Person's \"X2\"(default) likelihood-ratio statistic \"G2\"","code":""},{"path":"https://mpt-network.github.io/mptstan/reference/ppp_test.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Posterior Predictive P-values for MPTs — ppp_test","text":"Klauer, K. C. (2010). Hierarchical Multinomial Processing Tree Models: Latent-Trait Approach. Psychometrika, 75(1), 70-98. https://doi.org/10.1007/s11336-009-9141-0","code":""},{"path":"https://mpt-network.github.io/mptstan/reference/skk13.html","id":null,"dir":"Reference","previous_headings":"","what":"Singmann, Kellen, & Klauer (2013) ORE Data — skk13","title":"Singmann, Kellen, & Klauer (2013) ORE Data — skk13","text":"Data presented Singmann, Kellen, & Klauer (2013) investigating race effect (ORE) using unsure-extended 2-high threshold model. Participants perform face recognition memory test -race -race faces. original analysis performed using -pooling maximum likelihood estimation shows effect target race Dn parameter.","code":""},{"path":"https://mpt-network.github.io/mptstan/reference/skk13.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Singmann, Kellen, & Klauer (2013) ORE Data — skk13","text":"","code":"skk13"},{"path":[]},{"path":"https://mpt-network.github.io/mptstan/reference/skk13.html","id":"skk-","dir":"Reference","previous_headings":"","what":"skk13","title":"Singmann, Kellen, & Klauer (2013) ORE Data — skk13","text":"data frame 8,400 rows 7 variables: id Factor 42 levels indicating participant identifier. trial Factor indicating trial number. race Factor indicating race image shown, either german (-race) arabic (-race). type Factor indicating item type (.e., MPT tree), either old (.e., studied item) new (.e., non-studied item). resp Factor indicating response, either old, unsure, new. rt response time seconds. stim Factor 200 levels indicating shown image/item.","code":""},{"path":"https://mpt-network.github.io/mptstan/reference/skk13.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Singmann, Kellen, & Klauer (2013) ORE Data — skk13","text":"Singmann, H., Kellen, D., & Klauer, K. C. (2013). Investigating -Race Effect Germans towards Turks Arabs using Multinomial Processing Tree Models. M. Knauff, M. Pauen, N. Sebanz, & . Wachsmuth (Eds.), Proceedings 35th Annual Conference Cognitive Science Society (pp. 1330–1335). Austin, TX: Cognitive Science Society. http://singmann.org/download/publications/SKK-CogSci2013.pdf","code":""},{"path":"https://mpt-network.github.io/mptstan/reference/skk13.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Singmann, Kellen, & Klauer (2013) ORE Data — skk13","text":"original abstract follows: -race effect (ORE) refers phenomenon recognition memory -race faces worse -race faces. investigated whether White Germans exhibited ORE towards Turkish Arabic faces using multinomial processing tree model (MPT), two-high threshold model recognition memory three response categories (old, skip, new). Using MPT enabled us adequately disentangle memory response processes using Fisher information approximation, minimum description length based measure model complexity. Results showed participants exhibited ORE memory parameters parameters representing response processes.","code":""}]
